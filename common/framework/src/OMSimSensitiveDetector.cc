// OMSimSensitiveDetector.cc

#include "OMSimTrackingAction.hh"
#include "G4EventManager.hh"

#include "OMSimSensitiveDetector.hh"
#include "OMSimPMTResponse.hh"
#include "OMSimOpBoundaryProcess.hh"
#include "OMSimCommandArgsTable.hh"
#include "OMSimHitManager.hh"

#include "G4ios.hh"
#include "G4ParticleDefinition.hh"
#include "G4ParticleTypes.hh"
#include "G4Step.hh"
#include "G4TouchableHistory.hh"
#include "G4Track.hh"
#include "G4VTouchable.hh"
#include "G4OpticalPhoton.hh"
#include "G4VProcess.hh"
#include "G4ProcessVector.hh"
#include "G4ProcessManager.hh"
#include "OMSimTools.hh"
#include <G4EventManager.hh>
#include "G4RunManager.hh" // Added this include
#include "G4TransportationManager.hh" // Added this include
#include "G4TrackingManager.hh" // Added this include

thread_local G4OpBoundaryProcess *OMSimSensitiveDetector::m_boundaryProcess = nullptr;

/**
 * @brief Constructor for OMSimSensitiveDetector.
 * @param p_name Name of the sensitive detector.
 * @param p_detectorType Type of the detector (e.g., PMT, VolumePhotonDetector).
 */
OMSimSensitiveDetector::OMSimSensitiveDetector(G4String p_name, DetectorType pDetectorType)
    : G4VSensitiveDetector(p_name), m_detectorType(pDetectorType), m_PMTResponse(nullptr), m_QEcut(OMSimCommandArgsTable::getInstance().get<bool>("efficiency_cut"))
{
}

/**
 * @brief Destructor for OMSimSensitiveDetector.
 */

OMSimSensitiveDetector::~OMSimSensitiveDetector()
{
  delete m_PMTResponse;
  m_PMTResponse = nullptr;
}

/**
 * @brief Fetches the boundary process for detecting boundary absorptions.
 *
 * Retrieves and stores the `G4OpBoundaryProcess` to check for photon detection
 * at boundaries. Logs an error if the process is not found.
 */
void OMSimSensitiveDetector::fetchBoundaryProcess()
{
  G4ProcessManager *processManager = G4OpticalPhoton::OpticalPhoton()->GetProcessManager();
  G4ProcessVector *processVector = processManager->GetProcessList();
  for (int i = 0; i < processVector->length(); i++)
  {
    if (dynamic_cast<G4OpBoundaryProcess *>((*processVector)[i]))
    {
      m_boundaryProcess = (G4OpBoundaryProcess *)(*processVector)[i];
      break;
    }
  }
  if (!m_boundaryProcess)
  {
    G4cerr << "Error: G4OpBoundaryProcess not found!" << G4endl;
  }
}

/**
 * @brief Sets the PMT response model.
 * @param p_response Pointer to the PMT response object.
 */
void OMSimSensitiveDetector::setPMTResponse(OMSimPMTResponse *p_response)
{
  m_PMTResponse = p_response;
}

/**
 * @brief Processes hits for optical photons in the detector.
 *
 * If the detector type is one of the perfect detectors (100% efficient),
 * the photon hit is registered directly. Otherwise, it checks for volume
 * or boundary absorption based on the detector type.
 *
 * @param p_step The current step information.
 * @param p_touchableHistory The history of touchable objects.
 * @return True if the photon hit was stored, false otherwise.
 */
G4bool OMSimSensitiveDetector::ProcessHits(G4Step *p_step, G4TouchableHistory *p_touchableHistory)
{
  // Return false if the track is not an optical photon
  if (p_step->GetTrack()->GetDefinition() != G4OpticalPhoton::Definition())
    return false;
  // 2) Get photon info (includes wavelength)
  //PhotonInfo info = getPhotonInfo(p_step);
  // G4cout << " Photon wavelength hitting detector" << info.wavelength << G4endl;
  // Optical photons are anyway only generated by Cherenkov and Scintillation.. they are good
  //if (info.wavelength < 300.0 || info.wavelength > 500.0)
  //    return false;

  // Switch based on the detector type
  switch (m_detectorType)
  {
  case DetectorType::PMT:
    if (checkBoundaryAbsorption(p_step))
      return handlePMT(p_step, p_touchableHistory);
    return false;

  case DetectorType::PerfectPMT:
    return handlePMT(p_step, p_touchableHistory);

  case DetectorType::BoundaryPhotonDetector:
    if (checkBoundaryAbsorption(p_step))
      return handleGeneralPhotonDetector(p_step, p_touchableHistory);
    return false;

  case DetectorType::VolumePhotonDetector:
    if (checkVolumeAbsorption(p_step))
      return handleGeneralPhotonDetector(p_step, p_touchableHistory);
    return false;
    
  default:
    return false;
  }

  return false;
}

/**
 * @brief Retrieves photon information from a given step.
 *
 * @param p_step The current step information.
 * @return PhotonInfo struct containing the photon details.
 */

// OMSimSensitiveDetector.cc

PhotonInfo OMSimSensitiveDetector::getPhotonInfo(G4Step *p_step)
{
    PhotonInfo info;
    G4Track *track = p_step->GetTrack();

    // 1) Get the creation process name
    G4String creatorProcessName;
    G4String motherParticleName = "";

    G4String motherProcessName = "";
    const G4VProcess* creatorProcess = track->GetCreatorProcess();
    if (creatorProcess) {
        creatorProcessName = creatorProcess->GetProcessName();
    } else {
        // If there is no creator process, the track is a primary
        creatorProcessName = "Primary";
    }

    // 2) Retrieve parent particle type using TrackingAction
    G4int parentTrackID = track->GetParentID();

    if (parentTrackID != 0) { // Ensure it's not a primary particle
        // Retrieve parent particle type from TrackingAction
        motherParticleName = OMSimTrackingAction::GetInstance().GetParticleType(parentTrackID);

        // Retrieve parent process name from TrackingAction
        motherProcessName = OMSimTrackingAction::GetInstance().GetCreatorProcess(parentTrackID);

        // Handle cases where information might not be available
        if (motherParticleName.empty()) {
            motherParticleName = "UnknownParticle";
        }
        if (motherProcessName.empty()) {
            motherProcessName = "UnknownProcess";
        }
    }
    std::string parentParticleType;
    if (parentTrackID == 0) {
        // Primary particle
        parentParticleType = track->GetDefinition()->GetParticleName();
    } else {
        // Secondary or higher
        parentParticleType = OMSimTrackingAction::GetInstance().GetParticleType(parentTrackID);
        if (parentParticleType == "Unknown") {
            parentParticleType = "UnknownParent";
        }
    }

    // 3) Fill out the PhotonInfo fields
    info.parentID      = parentTrackID;
    info.parentType    = parentParticleType;
    info.eventID       = G4EventManager::GetEventManager()->GetConstCurrentEvent()->GetEventID();
    info.globalTime    = track->GetGlobalTime();
    info.localTime     = track->GetLocalTime();
    info.trackLength   = track->GetTrackLength() / m;
    info.kineticEnergy = track->GetKineticEnergy();

    // Planck's constant (eV·s) and speed of light (nm/s), for wavelength
    static const G4double planck_eVs = 4.135667696e-15 * eV * s;
    static const G4double c_nm_s     = 2.99792458e17 * nm / s;
    info.wavelength = planck_eVs * c_nm_s / info.kineticEnergy;

    info.globalPosition = track->GetPosition();
    G4ThreeVector localPos = p_step->GetPostStepPoint()
                                ->GetTouchableHandle()
                                ->GetHistory()
                                ->GetTopTransform()
                                .TransformPoint(info.globalPosition);
    info.localPosition    = localPos;
    info.momentumDirection= track->GetMomentumDirection();
    info.deltaPosition    = track->GetVertexPosition() - info.globalPosition;

    info.pmtNumber  = 0; // Will be set elsewhere if you find a PMT volume
    info.detectorID = std::atoi(SensitiveDetectorName);

    // 4) If you have a PMT response object, compute detection probability
    if (m_PMTResponse) {
        info.PMTResponse = m_PMTResponse->processPhotocathodeHit(localPos.x(), localPos.y(), info.wavelength);
    } else {
        info.PMTResponse = OMSimPMTResponse::PMTPulse({0, 0, 0});
    }

    // 5) Identify the origin (Cherenkov, eBrem, etc.) plus mother type
    if (creatorProcessName == "Cerenkov") {
        // Check the parent particle type to see if it's a muon
        if (parentParticleType == "mu+" || parentParticleType == "mu-") {
            info.photonOrigin = "Cerenkov from Muon"; // More specific origin
            info.parentProcess = "muIoni"; // Or whatever process the muon was undergoing
        } else if (parentParticleType == "e+" || parentParticleType == "e-") {
            info.photonOrigin = "Cerenkov from Electron"; // More specific origin
            info.parentProcess = "eIoni"; // Or whatever process the electron was undergoing
        }
        else {
            info.photonOrigin = "Cerenkov from Other";
            info.parentProcess = motherProcessName;
        }
    }
    else if (creatorProcessName == "eBrem") {
        info.photonOrigin = "Bremsstrahlung";
    }
    else if (creatorProcessName == "Scintillation") {
        info.photonOrigin = "Scintillation";
    }
    else if (creatorProcessName == "Primary") {
      if (track->GetDefinition() == G4OpticalPhoton::Definition()) {
        info.photonOrigin = "PrimaryOpticalPhoton";
      } else {
        info.photonOrigin = "Primary";
      }
    }
    else {
        info.photonOrigin = "Other";
    }

    // Append “ from [parentParticleType]”
    //info.photonOrigin += " from " + parentParticleType; // No longer needed
    info.parentProcess = motherProcessName;
    if (p_step->GetPreStepPoint()->GetStepStatus() == fGeomBoundary) {
        // The photon is entering the volume: record the time at the post-step point
        info.entryTime = p_step->GetPostStepPoint()->GetGlobalTime();
    } else {
        // For steps that are not the first, you might choose to leave it unchanged or assign a default value.
        // Here, we assign the global time (or you could set a flag value such as -1)
        info.entryTime = info.globalTime;
    }

    return info;
}
/**
 * @brief Checks if the photon was absorbed in the volume.
 *
 * @param p_step The current step information.
 * @return True if the photon was absorbed, false otherwise.
 */
G4bool OMSimSensitiveDetector::checkVolumeAbsorption(G4Step *pStep) {
  return pStep->GetPostStepPoint()->GetProcessDefinedStep()->GetProcessName() == "OpAbsorption" || pStep->GetTrack()->GetDefinition() != G4OpticalPhoton::Definition();
}

/**
 * @brief Checks if the photon was detected at a boundary.
 * @param p_step The current step information.
 * @return True if the photon was detected at the boundary, false otherwise.
 */
G4bool OMSimSensitiveDetector::checkBoundaryAbsorption(G4Step *pStep) {
    if (m_boundaryProcess == nullptr)
        fetchBoundaryProcess();

    if (pStep->GetPostStepPoint()->GetStepStatus() == fGeomBoundary)
    {
        if (m_boundaryProcess)
        {
            G4OpBoundaryProcessStatus boundaryStatus = m_boundaryProcess->GetStatus();
            if (boundaryStatus == G4OpBoundaryProcessStatus::Detection)
            {
                return true;
            }
        }
         // Check if it is not an optical photon
        if (pStep->GetTrack()->GetDefinition() != G4OpticalPhoton::Definition()) {
          return true;
        }
    }
    return false;
}

/**
 * @brief Monte carlo if the photon was detected based on the detection probability.
 * @param p_efficiency The detection probability.
 * @return True if the photon was detected, false otherwise.
 */
bool OMSimSensitiveDetector::isPhotonDetected(double p_efficiency)
{
  return G4UniformRand() < p_efficiency;
}

/**
 * @brief Handles hits for PMT detectors.
 * @param p_step The current step information.
 * @param p_touchableHistory The history of touchable objects.
 * @return True if the hit was stored, false otherwise.
 */
G4bool OMSimSensitiveDetector::handlePMT(G4Step *p_step, G4TouchableHistory *p_touchableHistory)
{
  PhotonInfo info = getPhotonInfo(p_step);

  // if QE cut is enabled, check if photon is detected (using detection probability, if detail PMT is enabled)
  if (m_QEcut && !isPhotonDetected(info.PMTResponse.detectionProbability))
    return false;
  else if (m_QEcut)
    info.PMTResponse.detectionProbability = 1; // if QE cut is enabled, detection probability is 1 as photon was detected

  G4TouchableHandle touchable = p_step->GetPreStepPoint()->GetTouchableHandle();
  G4String name;
  int i = 0;
  do
  {
    name = touchable->GetVolume(i)->GetName();
    i++;
  } while (name.substr(0, 3) != "PMT");

  std::vector<G4String> numberPMTstring = Tools::splitStringByDelimiter(name, '_');
  info.pmtNumber = atoi(numberPMTstring.at(1));
  storePhotonHit(info);
  killParticle(p_step->GetTrack());
  return true;
}

/**
 * @brief Handles hits for general photon detectors.
 * @param p_step The current step information.
 * @param p_touchableHistory The history of touchable objects.
 * @return True if the hit was stored, always true for general photon detectors.
 */
G4bool OMSimSensitiveDetector::handleGeneralPhotonDetector(G4Step *p_step, G4TouchableHistory *p_touchableHistory)
{
  PhotonInfo info = getPhotonInfo(p_step);
  info.pmtNumber = 0; // placeholder
  storePhotonHit(info);
  killParticle(p_step->GetTrack());
  return true;
}

/**
 * @brief Stores photon hit information into the HitManager
 * @param p_info The photon hit information.
 */
// OMSimSensitiveDetector.cc

void OMSimSensitiveDetector::storePhotonHit(PhotonInfo &p_info)
{
    OMSimHitManager &hitManager = OMSimHitManager::getInstance();
    hitManager.appendHitInfo(
        p_info.eventID,
        p_info.globalTime,
        p_info.entryTime,
        p_info.localTime,
        p_info.trackLength,
        p_info.kineticEnergy,
        p_info.pmtNumber,
        p_info.momentumDirection,
        p_info.globalPosition,
        p_info.localPosition,
        p_info.deltaPosition.mag(),
        p_info.PMTResponse,
        p_info.photonOrigin,
        p_info.parentID,        // Correctly pass parentID
        p_info.parentType,      // Correctly pass parentType
        p_info.parentProcess,      // Correctly pass parentType
        p_info.wavelength,      // Pass wavelength
        p_info.detectorID       // Pass moduleIndex (ensure this is correct)
    );
}


/**
 * @brief Stop the particle from propagating further. Necessary for 100% efficient detectors.
 */
void OMSimSensitiveDetector::killParticle(G4Track *pTrack)
{
  if (pTrack->GetTrackStatus() != fStopAndKill)
  {
    pTrack->SetTrackStatus(fStopAndKill);
  }
}